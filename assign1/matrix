#!/bin/bash
# Name: Travis Laxson
# Date: Jan. 18 2019
# Description: This shell script computes matrix operations 
# including printing the dimensions, matrix transpositions,
# mean vector calculation, addition of two matrices, and
# multiplication of two matrices. 

datafilepath="datafile$$"
tempCol="tempcolfile$$"
tempRow="temprowfile$$"
tempRow1="temprowfile1$$"
tempCol1="tempcolfile1$$"
tempfile="tempsumfile$$"
tempsumfile="sumfile$$"
tempsumfile2="sumfile2$$"
avgfile=$"tempavgfile$$"
tempdatafilepath=$"tempdatafile$$"
temptempfile=$"tempfile$$"
tempaddfile=$"tempaddfile$$"
tempfile1=$"tempfile1$$"
tempfile2=$"tempfile2$$"
matrix1tempfile="mat1tempfile$$"
matrix2tempfile="mat2tempfile$$"
trap "rm -f $tempCol $tempRow $avgfile" EXIT INT HUP TERM 	# File cleanup maintenance 

# Dims function: Prints the dimensions of the matrix
# as the number of rows, followed by a space, then the number
# of columns (e.g. For a 5x6 matrix stdout will show '5 6')
dims() {
	rows=$(wc -l < $datafilepath)		# Get number of rows
	numcount=$(wc -w < $datafilepath)	# Get total number count
	cols=$(( numcount / rows ))		# Calculate number of columns
	echo "$rows $cols"			# Display rows and cols
}

# Transpose function: Reflects the elements of the matrix 
# along the main diagonal. (Eg. An MxN matrix becomes NxM)
# Values along the main diagonal will remain unchanged.
transpose() {
	i=0
	#Make input row file
	while read numberLine
	do
		colscount=0
		for each in $numberLine 
		do			
			colscount=$(( colscount + 1 ))
		done
		
		while [[ $i -lt $colscount ]]
		do
			(( i++ ))	
			col=$(cut -f $i $datafilepath | tr '\n' '\t')
			echo "${col%?}" >> $tempCol
		done
	done < $datafilepath
	cat < $tempCol
}

# Mean function: Takes an MxN matrix input and returns an 1xN
# row vector where the first element is the mean of column 1
# and the second element is the mean of column 2, and so on.
mean() {
	#Get the number of columns
	numcount=$( wc -w < $datafilepath)
	#echo "Number of nos.= $numcount"
	lincount=$( wc -l < $datafilepath)
	#echo "Number of lines= $lincount"
	colcount=$(( numcount / lincount))
	#echo "Number of cols= $colcount"

	#initialize counter var
	i=1

	while [[ $i -le $colcount ]]
	do 
	
		#initialize sum & avg for each column
		sum=0
		avg=0
	
		#cut columns and store into tempfile
		cutcol=$(cut -f $i $datafilepath)
		echo "$cutcol" > $tempCol
		#cat $tempCol

		#Read each numebr from the tempCol file and calculate sum
		while read number
		do
			sum=$(( sum + number )) 
		#	echo "Sum=$sum"
		done < $tempCol

		#Calculate float average
		avg=$(( ($sum + ($lincount/2) * (($sum>0)*2-1)) / $lincount ))
		#echo "Avg=$avg"
		
		#Append avg to avgfile 
		echo "$avg" >> $avgfile

		#Tranform avgfile from cols to rows (replace all newlines with tabs)
		display=$(cat $avgfile | tr '\n' '\t')

		#Overwrite avgfile with transformed display minus last tab
		echo "${display%?}" > $avgfile

	#Increment i value
	(( i++ ))

	done

	#Display avgfile to terminal
	cat $avgfile	

}

add() {
	# Declare arrays
	numarray1=( $(cat $datafilepath) )	# $Arg2 from command line
	numarray2=( $(cat $tempfile) )		# $Arg3 from command line
	
	# Initialize counter used to maintain array dimensions
	count=1

	# Iterate through all array elements
	# Source: https://stackoverflow.com/questions/17403498/iterate-over-two-arrays-simultaneously-in-bash
	for ((i=0; i<${#numarray1[@]};++i))	
	do
		# Calculate resulting sum iteratively from arrays
		sum=0
		sum=$(( ${numarray1[i]} + ${numarray2[i]} ))
	
		# Maintain dims of sum vector array with original 
		if [[ $count -lt $datafilepathcols ]]
		then
			# Print sum on same line separated by tab
			printf "%d\t" $sum 
		
			# Increment count var
			(( count++ ))
		else	
			# Print sum on new line
			printf "%d\n" $sum
			
			# Reset count for new row
			count=1
		fi
	done
}


multiply() {

	# Get rows and cols for matrix 1	
	matrix1rows=$(wc -l < $matrix1tempfile)
	matrix1nums=$(wc -w < $matrix1tempfile)
	matrix1cols=$(( matrix1nums / matrix1rows ))
	
	# Get matrix 2 rows and cols
	matrix2rows=$(wc -l < $matrix2tempfile)
	matrix2nums=$(wc -w < $matrix2tempfile)
	matrix2cols=$(( matrix2nums / matrix2rows ))
	
	# Determine rows and cols of product matrix
	matrix3rows=$matrix1rows
	matrix3cols=$matrix2cols

	# Declare matrices
	declare -a matrix1
	declare -a matrix2
	matrix1=( $(cat "$matrix1tempfile") )    
	matrix2=( $(cat "$matrix2tempfile") )       
	
	
	# Matrix multiplication logic 
	count=1
	for ((row=0; row<$matrix3rows; row++))
	do
		for ((col=0; col<$matrix3cols; col++))
		do
			product=0
			for ((i=0; i<$matrix1cols; i++))

			do
				row1="$row"
#				echo "row1=$row1"
				col1="$i"
#				echo "col1=$col1"
				index1=$(( (row1 * matrix1cols) + col1 ))
#				echo "index1=$index1"
				row2="$i"
#				echo "row2=$row2"
				col2="$col"
#				echo "col2=$col2"
				index2=$(( (row2 * matrix2cols) + col2 ))
#				echo "index2=$index2"
				matrix1output=${matrix1[$index1]}
				matrix2output=${matrix2[$index2]}
#				echo "$matrix1output * $matrix2output"
				subtot=$(( matrix1output * matrix2output ))
				product=$(( product + subtot ))
			done
				# Format stdout of product matrix	
				if [[ $count -lt $matrix3cols ]]
				then
					printf "%d\t" $product   #>> $tempRow
					(( count++ ))
				else
					count=1
					printf "%d\n" $product   #>> $tempRow
				fi
		done
	done
}



# How the script handles piping stdout into stdin
# and stdin directly as a command line argument 
if [[ "$1" == "dims" ]] || [[ "$1" == "transpose" ]] || [[ "$1" == "mean" ]]
then
	if [[ $# -eq 1 ]]
	then
		cat > $datafilepath		#read in stdin to data file
	elif [[ $# -eq 2 ]]
	then
		datafilepath=$2
	else
		echo "Error: Invalid number of arguments." 1>&2
		exit 1
	fi	
	
	if [[ ! -f $datafilepath ]]
	then
		echo "Error: File $datafilepath does not exist." 1>&2
		exit 1
	fi
elif [[ "$1" == "add" ]] #|| [[ "$1" == "multiply" ]]
then
	if [[ "$#" != "3" ]]  
	then
		echo "Invalid argument count. Enter two arguments only." 1>&2
		exit 1
	else 
		datafilepath=$2 
		tempfile=$3
		datafilepathlines=$(wc -l < $datafilepath)
		datafilepathwords=$(wc -w < $datafilepath)
		datafilepathcols=$(( datafilepathwords / datafilepathlines ))
		
		tempfilepathlines=$(wc -l < $tempfile)
		tempfilepathwords=$(wc -w < $tempfile)
		tempfilepathcols=$(( tempfilepathwords / tempfilepathlines ))

		if [[ $datafilepathlines != $tempfilepathlines ]] || [[ $datafilepathcols != $tempfilepathcols ]]
		then
			echo "Wrong sized matrices!" 1>&2
			exit 1
		fi
	fi
	if [[ ! -f $datafilepath ]]
	then
		echo "Error: File $datafilepath does not exist." 1>&2
		exit 1
	fi
elif [[ $1 == "multiply" ]]
then
	# Assign command line arguments to tempfiles
	matrix1tempfile=$2
	matrix2tempfile=$3
	
	# Get number of rows and cols for matrices 1 & 2
	matrix1rows=$(wc -l < $matrix1tempfile)
	matrix1nums=$(wc -w < $matrix1tempfile)
	matrix1cols=$(( matrix1nums / matrix1rows ))
	matrix2rows=$(wc -l < $matrix2tempfile)
	matrix2nums=$(wc -w < $matrix2tempfile)
	matrix2cols=$(( matrix2nums / matrix2rows ))
	
	# Check for valid argument count
	if [[ "$#" != "3" ]]  
	then
		echo "Invalid argument count. Enter two arguments only." 1>&2
		exit 1
	# Check if matrix multiplication is allowed based on passed in arguments
	elif [[ $matrix1cols != $matrix2rows ]]
	then
		echo "Invalid sized matrices. Double-check cols of matrix1 equals rows of matrix2" 1>&2
		exit 1
	# Check if files exist 
	elif [[ ! -f $matrix1tempfile ]] || [[ ! -f $matrix2tempfile ]]
	then
		echo "File not found. Pass valid file argument with command." 1>&2
		exit 1
	fi
fi

$1 "${@:2}"
